// Flappy -- http://tinyc.games -- (c) 2020 Jer Wilson
//
// Flappy is an extremely small implementation of the Flappy Bird game.

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define SDL_DISABLE_IMMINTRIN_H
#include <SDL3/SDL.h>
#include <SDL3/SDL_main.h>
#include <SDL3_ttf/SDL_ttf.h>

#define TINYC_DIR ".."
#include "build-config.h" // generated by CMake from build-config.h.in

#define W 480
#define H 600
#define GROUND 80
#define PIPE_W 86
#define PHYS_W (W + PIPE_W + 80)
#define GAP 220
#define GRACE 4
#define RANDOM_PIPE_HEIGHT (rand() % (H - GROUND - GAP - 120) + 60)
#define PLYR_X 80
#define PLYR_SZ 60

enum gamestates {READY, ALIVE, GAMEOVER} gamestate = READY;

typedef struct {
    float y;
    float vel;
} Bird;

typedef struct Pipe {
    int x;
    float y;
    struct Pipe *next; //linked list
} Pipe;

Bird *bird;
Pipe *pipes;
bool has_collision = true;
int best;
int idle_time = 30;
float frame = 0;

SDL_Event event;
SDL_Renderer *renderer;
SDL_Surface *surf;
SDL_Texture *pillar;
SDL_Texture *background;
SDL_Texture *bird_texture[4]; //naming conflict
TTF_Font *font;

void setup();
void new_game(int *score);
void update_stuff(int *score);
void update_pipe(Pipe *p, int *score);
void draw_stuff(int *score);
void text(char *fstr, int value, int height);
void increment_score(int *score);
Pipe *create_pipe(int x);
void debug_set_no_collision();
void update_bird_position(Bird *bird, float, float);
void set_game_over();

//the entry point and main game loop
int main()
{
        int score;
        setup();

        for(;;)
        {
                while(SDL_PollEvent(&event)) switch(event.type)
                {
                        case SDL_EVENT_QUIT:
                                exit(0);
                        case SDL_EVENT_KEY_DOWN:
                        case SDL_EVENT_MOUSE_BUTTON_DOWN:
                                if(gamestate == ALIVE)
                                {
                                        bird->vel = -11.7f;
                                        frame += 1.0f;
                                }
                                else if(idle_time > 30)
                                {
                                        new_game(&score);
                                }
                }

                update_stuff(&score);
                draw_stuff(&score);
                SDL_Delay(1000 / 60);
                idle_time++;
        }
}

Pipe *create_pipe(int x)
{
        Pipe *p = (Pipe *)malloc(sizeof(Pipe));
        p->x = x;
        p->y = RANDOM_PIPE_HEIGHT;
        p->next = NULL;
        return p;
}

void debug_set_no_collision() {
        has_collision = false;
}

void update_bird_position(Bird *bird, float y, float vel) {
        bird->y = y;
        bird->vel = vel;
}

void set_game_over() {
        gamestate = GAMEOVER;
}

//initial setup to get the window and rendering going
void setup()
{
        srand(time(NULL));

        //allocate with malloc
        bird = (Bird *)malloc(sizeof(Bird));
        update_bird_position(bird, (H - GROUND)/2, 0);

        pipes = create_pipe(W);
        pipes->next = create_pipe(W);

        SDL_Init(SDL_INIT_VIDEO);
        SDL_Window *win = SDL_CreateWindow("Flappy", W, H, 0);
        renderer = SDL_CreateRenderer(win, NULL);
        if(!renderer) exit(fprintf(stderr, "Could not create SDL renderer\n"));

        surf = SDL_LoadBMP(TINYC_DIR "/flappy-game/assets/pillar.bmp");
        SDL_SetSurfaceColorKey(surf, 1, 0xffff00);
        pillar = SDL_CreateTextureFromSurface(renderer, surf);
        surf = SDL_LoadBMP(TINYC_DIR "/flappy-game/assets/background.bmp");
        background = SDL_CreateTextureFromSurface(renderer, surf);

        for(int i = 0; i < 4; i++)
        {
                char file[80];
                sprintf(file, TINYC_DIR "/flappy-game/assets/bird-%d.bmp", i);
                surf = SDL_LoadBMP(file);
                SDL_SetSurfaceColorKey(surf, 1, 0xffff00);
                bird_texture[i] = SDL_CreateTextureFromSurface(renderer, surf);
        }

        TTF_Init();
        font = TTF_OpenFont(TINYC_DIR "/common/fonts/LiberationMono-Regular.ttf", 42);
}

//start a new game
void new_game(int *score)
{
        gamestate = ALIVE;
        update_bird_position(bird, (H - GROUND)/2, -11.7f);
        *score = 0;
        Pipe *p = pipes;
        while (p)
        {
                Pipe *next = p->next;
                free(p);
                p = next;
        }
        pipes = create_pipe(PHYS_W + PHYS_W/2 - PIPE_W);
        pipes->next = create_pipe(PHYS_W - PIPE_W);
}

//when we hit something
void collision(int *score)
{
        if (has_collision == true)
        {
                set_game_over();
                idle_time = 0;
                if(best < *score) best = *score;
        }
        
}

//update everything that needs to update on its own, without input
void update_stuff(int *score)
{
        if(gamestate != ALIVE) return;

        update_bird_position(bird, bird->y+bird->vel, bird->vel+0.61f); //gravity

        if(bird->vel > 10.0f)
                frame = 0;
        else
                frame -= (bird->vel - 10.0f) * 0.03f; //fancy animation

        if(bird->y > H - GROUND - PLYR_SZ)
        {
                collision(score);
                bird->y = H - GROUND - PLYR_SZ; //keep bird on floor when no collision
        }
                

        Pipe *p = pipes;
        while (p) 
        {       
                Pipe *next = p->next;
                update_pipe(p, score);
                p = next;
        }
}

void increment_score(int *score) {
        *score = *score + 1;
}

//update one pipe for one frame
void update_pipe(Pipe *p, int *score)
{
        if(PLYR_X + PLYR_SZ >= p->x + GRACE && PLYR_X <= p->x + PIPE_W - GRACE &&
                (bird->y <= p->y - GRACE || bird->y + PLYR_SZ >= p->y + GAP + GRACE))
                collision(score); // player hit pipe

        // move pipes and increment score if we just passed one
        p->x -= 5;
        if(p->x + PIPE_W < PLYR_X && p->x + PIPE_W > PLYR_X - 5)
                increment_score(score);

        // respawn pipe once far enough off screen
        if(p->x <= -PIPE_W)
        {
        
        //find prev pipe to remove
        Pipe *prev = pipes;
        
        
        while (prev && prev->next != p)
        {
                prev = prev->next;
        }

        //remove current pipe from list
        if (prev)
        {
                prev->next = p->next;
        }
        else
        {
                pipes = p->next;
        }

        //add new pipe at the end of the list
        Pipe *last = pipes;
        //printf("cur:  %p\n", (void*)last); //debug prints
        while (last && last->next)
        {
                last = last->next;
        }
        last->next = create_pipe(PHYS_W - PIPE_W);
        //printf("next: %p\n", (void*)last->next); //debug prints
        //free old pipe
        free(p);
        }
}

//draw everything in the game on the screen
void draw_stuff(int *score)
{
        SDL_FRect dest = {0, 0, W, H};
        SDL_RenderTexture(renderer, background, NULL, &dest);

        //draw pipes via linked list
        Pipe *p = pipes;
        while (p)
        {
                int lower = p->y + GAP;
                SDL_RenderTexture(renderer, pillar, NULL, &(SDL_FRect){p->x, p->y - H, PIPE_W, H});
                SDL_FRect src = {0, 0, 86, H - lower - GROUND};
                SDL_RenderTexture(renderer, pillar, &src, &(SDL_FRect){p->x, lower, PIPE_W, src.h});
                p = p->next;
        }

        //draw player
        SDL_RenderTexture(renderer, bird_texture[(int)frame % 4], NULL,
                        &(SDL_FRect){PLYR_X, bird->y, PLYR_SZ, PLYR_SZ});

        if (gamestate != READY) text("%d", *score, 10);
        if (gamestate == GAMEOVER) text("High score: %d", best, 170);
        if (gamestate == READY || gamestate == GAMEOVER) text("Press any key", 0, 240);

        SDL_RenderPresent(renderer);
}

void text(char *fstr, int value, int height)
{
        if(!font) return;
        int w, h;
        char msg[80];
        snprintf(msg, 80, fstr, value);
        TTF_Text *txt = TTF_CreateText(NULL, font, msg, 0);
        TTF_GetTextSize(txt, &w, &h);
        SDL_Surface *msgsurf = TTF_RenderText_Blended(font, msg, 0, (SDL_Color){255, 255, 255});
        SDL_Texture *msgtex = SDL_CreateTextureFromSurface(renderer, msgsurf);
        SDL_FRect fromrec = {0, 0, msgsurf->w, msgsurf->h};
        SDL_FRect torec = {(W - w)/2, height, msgsurf->w, msgsurf->h};
        SDL_RenderTexture(renderer, msgtex, &fromrec, &torec);
        SDL_DestroyTexture(msgtex);
        SDL_DestroySurface(msgsurf);
}
